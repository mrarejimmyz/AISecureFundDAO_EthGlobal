// SPDX-License-Identifier: MIT
pragma solidity ^0.8.26;

import "./interfaces/ITEE.sol";
import "./PrivateVoting.sol";

/**
 * @title SealedBidAuction - Hackathon Demo Version
 * @dev Sealed bid auction using Marlin's TEE for privacy with voting integration
 */
contract SealedBidAuction {
    // Marlin TEE address
    address public immutable MARLIN_TEE_ADDRESS;
    // Reference to PrivateVoting contract
    PrivateVoting public privateVoting;

    struct Auction {
        uint256 projectId;
        uint256 endTime;
        bool finalized;
        address winner;
        uint256 winningBid;
        // Adds AI insights hash generated by Nillion SecretLLM
        bytes32 aiInsightsHash;
    }

    // Simplified storage
    mapping(uint256 => Auction) public auctions;
    mapping(uint256 => mapping(address => bytes32)) public sealedBids;

    // Basic events
    event AuctionCreated(uint256 indexed projectId, uint256 endTime);
    event BidPlaced(uint256 indexed projectId, address indexed bidder);
    event AuctionFinalized(
        uint256 indexed projectId,
        address winner,
        uint256 winningBid,
        bytes32 aiInsightsHash
    );

    constructor(address _marlinTeeAddress, address _privateVotingAddress) {
        MARLIN_TEE_ADDRESS = _marlinTeeAddress;
        privateVoting = PrivateVoting(_privateVotingAddress);
    }

    /**
     * @dev Create auction for a project that passed DAO voting
     */
    function createAuction(uint256 projectId, uint256 duration) external {
        // Check if project was approved in voting
        require(
            privateVoting.isProjectApproved(projectId),
            "Project not approved by DAO"
        );

        auctions[projectId] = Auction({
            projectId: projectId,
            endTime: block.timestamp + duration,
            finalized: false,
            winner: address(0),
            winningBid: 0,
            aiInsightsHash: bytes32(0)
        });

        emit AuctionCreated(projectId, block.timestamp + duration);
    }

    /**
     * @dev Submit a sealed bid using TEE
     */
    function submitBid(uint256 projectId, bytes32 sealedBid) external {
        require(block.timestamp < auctions[projectId].endTime, "Auction ended");
        require(!auctions[projectId].finalized, "Auction finalized");

        // Get attestation nonce from Marlin TEE
        bytes32 teeNonce = ITEE(MARLIN_TEE_ADDRESS).getAttestationNonce();

        // Store bid with TEE attestation binding
        sealedBids[projectId][msg.sender] = keccak256(
            abi.encodePacked(sealedBid, teeNonce)
        );

        emit BidPlaced(projectId, msg.sender);
    }

    /**
     * @dev Finalize auction with TEE-based winner determination and AI insights
     */
    function finalizeAuction(
        uint256 projectId,
        address winner,
        uint256 winningBid,
        bytes32 aiInsightsHash,
        bytes calldata teeProof
    ) external {
        Auction storage auction = auctions[projectId];
        require(block.timestamp >= auction.endTime, "Auction not ended");
        require(!auction.finalized, "Already finalized");

        // Verify the result came from the TEE
        require(
            ITEE(MARLIN_TEE_ADDRESS).verifyAuctionResult(
                projectId,
                winner,
                winningBid,
                teeProof
            ),
            "Invalid TEE verification"
        );

        // Update auction with winner and AI insights
        auction.winner = winner;
        auction.winningBid = winningBid;
        auction.aiInsightsHash = aiInsightsHash;
        auction.finalized = true;

        emit AuctionFinalized(projectId, winner, winningBid, aiInsightsHash);
    }

    /**
     * @dev Get current auction status with AI insights
     */
    function getAuctionStatus(
        uint256 projectId
    )
        external
        view
        returns (
            uint256 endTime,
            bool finalized,
            address winner,
            uint256 winningBid,
            bytes32 aiInsightsHash
        )
    {
        Auction storage auction = auctions[projectId];
        return (
            auction.endTime,
            auction.finalized,
            auction.winner,
            auction.winningBid,
            auction.aiInsightsHash
        );
    }
}
